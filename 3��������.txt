객체 : 실세계 명사 표현 ===> 자바 s/w 단위 
1.객체특성파악(분석설계)
정적:상ㅌ애, 정보, 속성 표현 ===>변수 표현
동적:행위, 동작, 기능 표현 ===> 메서드 표현
2.클래스 정의
객체의 틀, template, 원형 정의
정적===>변수 표현
동적===> 메서드 표현
3.객체 생성
(=클래스 변수와메서드 복사 메모리 할당)
"new" 

클래스
선언부
modifier : 활용방법이나 접근권한 표현 키워드들

접근권한
public protected private 
활용방법 
static final abstract
멤버부
멤버변수/생성자/메서드
멤버변수(<--->지역변수)
[modifier] 타입 변수명;
접근권한
public : 모든 클래스 변수 사용 
protected :(default) + 다른 ㅍ패키지의 상속받은 클래스

(default=no modifier상태):현재 패키지에서만 변수 사용
private : 현재 클래스에서만 변수 사용

활용방법 
static :"정적"
모든 객체 하나의 공통값 공유
=클래스변수
클래스영역/1개만 
클래스명.static변수
객체참조변수명.static변수

non-static :"동적"
객체마다 별도값 저장 
=객체변수
객체영역/객체생성개수만큼 
클래스명.non-static변수====.error
객체참조변수명.non-static변수

class A{
 ...main(){===> 실행되자마자 static변수 메모리 할당
 s.o.p(B.j);
  B b1 = new B();==>B non-static변수 메모리 할당
  b1.i...
  b1 = null;===> B객체 메모리 삭제
  
  
}

class B{
 int i = 10;
 static int j = 20;
 }
 
 s  
final : 값 수정불가능=상수
절대불변의진리값/자바규칙계산된값/공유값/대문자구성이름
  Math.PI
  Integer.MAX_VALUE
  static final int i


생성자
객체특성표현도구아니다(변수와메서드)
클래스정의---> 객체생성 문장 사용시 호출하여
실행 문장 정의 
형태
[modifier] 클래스이름([매개변수]){
객체생성 문장 사용시 호출하여
실행 문장 정의 
}
1) 클래스이름과 같다
2) 리턴타입 없다
3) new 키워드 뒤 호출 가능
4) 자동 기본 생성자 포함 정의
클래스이름(){ super(); }
5) 사용자 생성자 정의하면 기본 생성자 자동 삭제
6) 생성자 overloading
하나의 클래스에 같은 이름의 생성자 여러개 존재
매개변수타입이나 순서나 개수중 하나가 다르게 정의
7) this : 자신 객체 키워드
   7-1. this.멤버변수명: 멤버변수와 지역변수(매ㅔ개변수)
   이름이 같은 경우 구분
   7-2. this([변수...]):생성자 overloading시에
   다른 생성자 호출

api(정수나 문자열 데이터타입 관련)
java.lang.String클래스
특징
1) + 연산자 이용하여 문자열 결합 가능
String s1 = new String("java");
String s2 = new String("servlet");

s1.concate(s2) ===> "javaservlet";
(객체, 클래스, api 개념 취급방법 알아야 사용가능)

s1 + s2 ===> "javaservlet";
(객체, 클래스, api 개념 취급방법 몰라도 사용가능)

s.o.p("java" + i + "*" + "=" 

2)new 키워드 없이도 객체생성 가능
String s1 ="java";
String s2 ="java";
String s3 = new String("java");
String s4 = new String("java");

if(s1 == s2)
if(s3 == s4)
if(s1.equals(s2))
if(s3.equals(s4))

== 연산자 : 두 문자열 저장 주소값 비교
equals 메서드 : 두 문자열 내용 동등성 비교



역할 : 문자열 취급 
char c = 'a'
String s = "aaa";

변수:대문자/소문자판별변수
메서드:
equals():문자열 내용 동등성 비교
concate():두 문자열 하나로 결합
toUpperCase() , toLowerCase()
"scjp".replace('j', 'k')
"program-java-jsp-servlet".split("-")


java.lang.Integer클래스
int i = 10;
int j = 20;
String s = "30";
연산자 제공 : i + j
 십진수-->이진수/8/16진수 변경
 --> Integer.toHexString(-2)
 String-->int 변경
형변환연산자(boolean제외한 기본형변수끼리만 가능) 
역할:int타입 연산자로 제공되지 않는 기능
미리 구현하여 제공 클래스

변수:최대값/최소값 
메서드:toHexString, toOctalString() toBinaryString9)
       parseInt()

생성자:2개 overloading
new Integer(100)
new Integer("100")

-----------------------------------------------------
멤버변수/생성자
메서드:객체동적특성표현(기능,행위)
객체마다 동적특성 반복 ==> 1번만 정의하고 호출

[modifier] 리턴타입 이름([매개변수]){
 객체 기능 표현 문장 정의
}

- 리턴타입 개념:기본형변수+참조형변수+ void

m(){
....
....
}

void ma(){
 int result1 = mb();-->호출
 String result2 = mc();
 md();
}
void md(){
 int j = 10;
 s.o.p(j*j);
 ==> 완료된 후에 ma() 이동하면서 전달 결과 없다
}
 
String mc(){
....
 return "java";
}
 
int  mb(){-->.이동
 int j = 10;--.지역변수
 return j*j;==> 메서드마지막문장
 메서드 완료된 후에 ma() 이동하면서
 j*j 변수값 전달
}
  


- 구현부


- static 메서드:static변수
클래스메서드
클래스영역
1개
공유변수 사용 메서드
클래스명.static메서드
객체참조변수명.static메서드

non-static 메서드
객체메서드
객체영역
객체생성개수만큼
객체변수 사용 메서드
클래스명.non-static메서드====>error
객체참조변수명.non-static메서드


- java.exe 명령(run메뉴) 실행 과정 3단계
  1)class load time
  :클래스영역 static변수와 메서드 저장 
  2)(static직접연관x) : code verify
    내컴퓨터:A.java{B...}, B.java-->A.class, B.class
    -->다운로드(A.class)-->내친구컴퓨터:실행오류
    
  3)main()실행:객체생성시점.
  객체변수와 객체메서드 저장
  this 키워드 사용 


Test.m1(), o1.m1(), o2.m1()
==>사용가능(공통 1개 메서드호출)
static 메서드는 모든 객체 공유
클래스영역 사용 가능

Test.m2()==>사용불가능(Test영역 존재x)
o1.m2(), o2.m2()==>서로 다른 객체 내부 다른 메서드 호출
객체메서드는 객체마다 서로 다른 메서드 호출
객체영역 저장 가능

static 메서드 내부에서ㅗ는
사용가능:static변수와 static메서드만

사용불가능:객체변수와 객체메서드, this 키워드



- 메서드 overloading:생성자
하나의 클래스에 이름이 같은 메서드 여러개 정의
매개변수 개수, 타입, 순서중 하나가 다르게 정의
리턴타입, modifier 제한없다

===> 동일 기능을 매개변수에 따라서 다양하게 제공
     선택적 호출 가능
 
int i = Integer.parseInt("100") 
--> String을 10진 정수 변경(100 출력)

int i = Integer.parseInt("100", 2) 
--> String을 2진 정수 변경(4 출력) 

-객체지향언어조건
캡슐화와 정보은닉
상속
다형성
1)생성자 overloading
2)메서드 overloading
3)메서드 overriding
 


- 매개변수 개념, 전달원리
void ma(){
 int i = 10;
 mb(i);==>호출하면서 실제 i 값 전달 
   i : 실매개변수
}
 
 void mb(int k){
 ==>mb()호출시에 외부로부터 int 1개 필요 정의
    k : 형식매개변수 정의
 ...
 }
 
자바 : 메서드, 생성자 호출 : 매개변수 정의-전달

실매개변수를 형식매개변수로 전달 과정 필요


call by value(값):
실매개변수값을 복사 형식매개변수로 전달

기본형변수:실제값 복사 형식매개변수로 전달
전달 이후에 메서드내부에서 형식매개변수(i)값 변경되면
실매개변수(j)값 변경x


참조형변수:주소값 복사 형식매개변수로 전달
실매개변수와 형식매개변수 참조 객체 주소 동일
전달 이후에 메서드내부에서 형식매개변수(s) 참조
객체(1000번지) 내부의 변수값(s.a) 변경되면
실매개변수 참조 객체(1000번지) 내부 변수값(t.a) 
변경o


========================================


- public protected private ===> 멤버변수 동일 
  static 
  final abstract ==> 7장 상속  



7장 상속

상속과 변수
1. 상위클래스 변수 하위클래스 자동 포함 사용 가능
2. private 변수 사용 불가능
3. 상,하위클래스 동일명 변수 존재.
하위클래스 변수 우선적 인식 사용 
상위클래스 변수(super 키워드 이용)
4.상,하위클래스 static 동일명 변수 존재.
하위클래스 변수 우선적 인식 사용 
상위클래스 변수(상위클래스명.xxxx)

상속과 메서드 해당 

상속과 메서드 overriding
상속관계 두 클래스에서 상위클래스의 메서드
내용을 수정하여 재정의
이름, 매개변수, 리턴타입 동일해야 하고
modifier 동일하거나 더 넓을 수 있다.

class 회사원{
 본봉, 사원수당, 총급여;
 급여계산(){ 총급여 = 본봉 + 사원수당; }
} 

class 임원 extends 회사원{
임원수당;
 급여계산(){ 총급여 = 본봉 + 임원수당*부하직원수 ; }
}

임원 man = new 임원();
man.급여계산();==>총급여 = 본봉 + 임원수당*부하직원수 ;

public class Object{
....
public boolean equals(Object obj){
 두 객체 주소값 동등성 비교 기능
}
}

public class String extends Object{
 //equals() 문자열 내용 비교 기능 오버라이딩
public boolean equals(Object obj){ 
문자열 내용 비교 기능
}
}

다형성 표현 구문
메서드 overloading
하나의 클래스에 같은 이름의 메서드 여러개 정의
매개변수 개수나 타입이나 순서 하나이상 다르게 정의
리턴타입,modifier 제한없다
===> 하나 기능을 매개변수 따라 여러개 제공

메서드 overriding
상속 두 클래스에 같은 이름의 메서드 여러개 정의
매개변수,  리턴타입,modifier 동일하거나
modifier 더 넓어야 한다
==> 상위클래스 정한 메서드 내용 수정하여
다른 내용 제공

메서드 modifier
public protected private : 멤버변수 의미 동일
static :공유

"상속과 overriding 연관"
final변수:값 수정 불가능=상수이용.대문자이름

final메서드:메서드 내용 수정 불가능
           =메서드 overriding 금지
           
final클래스:모든메서드 overriding 금지
            상속금지, 객체생성으로만 사용가능
            ==> 상속과 overriding 금지
            
---------------------------------------------

abstract:추상적(구체적x)<--->final
===>  
abstract메서드
선언부만 있고 구현부 없는 메서드 정의
메서드 overriding의무화

abstract클래스
abstract메서드 하나 이상 포함 클래스 정의
객체생성불가능, 상속 의무화
===> 
여러개 서로 다른 클래스에서 공통 구현
기능 스펙, 명세서 제공

abstract class 도형{
 abstract void 면적();
 abstract void 둘레();
}//팀장(여러 도형들에서 공통 구현 필요 메서드 선언)

class 사각형 extends 도형{
 void 면적(){가로 * 세로;}
 void 둘레(){2*(가로 + 세로);}
 +....
}//a

class 원 extends 도형{
 void 면적(){반지름 * 반지름 * 원주율;}
 void 둘레(){2 * 반지름 * 원주율;}
}//b

class 삼각형 extends 도형
class 오각형 extends 도형
오각형 클래스 추가
main 오각형 객체 생성
     오각형 객체 면적/둘레 메서드 호출 결과 출력
     

도형 shape = new 도형();
==> (error)
도형 변수와 메서드 구현부 (이진수...) 메모리 할당불가능

-----------------------
//팀장
class 사각형 {
 void 면적(){가로 * 세로;}
 +....
}//a

class 원 {
 void 둘레(){2 * 반지름 * 원주율;}
}//b

class 삼각형 {
..
}
//c

//d
-----------------------


api
final클래스:객체생성
abstract클래스:상속/overriding

13장(금요일)
class A extends InputStream {
//InputStream 구현완료 메서드 그대로 사용
 public int read(){
   파일, db, 키보드 입력 방법 다양하게 제공
 }
}

상속과 생성자 
class A extedends C{...}
class B extends A{....}

B b1 = new B();

B객체생성=B 변수와 메서드 복사 메모리 할당=B생성자호출
+(jvm자동실행호출:super())
A객체생성=A 변수와 메서드 복사 메모리 할당=A생성자호출

하위클래스 객체 생성시에는
자동으로(jvm) 상위클래스 객체 먼저 생성


super:상위클래스 객체 의미 키워드
1. 상위클래스 멤버변수와 하위클래스 멤버변수 이름 동일
   super.멤버변수====>상위클래스
   super.메서드()====>상위클래스
2.상위클래스 생성자 호출
  super():첫문장 자동 정의.
          상위클래스 기본 생성자 호출
  super(매개변수):첫문장 명시적 정의
          상위클래스 매개변수 정의한 생성자 호출

